package pw.binom.db.serialization

import kotlinx.serialization.KSerializer
import kotlinx.serialization.builtins.serializer
import pw.binom.db.DatabaseEngine
import pw.binom.db.async.AsyncResultSet
import pw.binom.db.async.pool.AsyncConnectionPool

internal class DBContextImpl(val pool: AsyncConnectionPool, val sql: SQLSerialization) : DBContext {
    private val tx = TransactionManagerImpl(pool)
    val statements = HashMap<String, SQLQueryNamedArguments>()
    val mappers = HashMap<KSerializer<out Any>, suspend (AsyncResultSet) -> Any>()
    private val entityDescriptions = HashMap<KSerializer<out Any>, EntityDescription>()
    override fun getDescription(serializer: KSerializer<out Any>) =
        entityDescriptions.getOrPut(serializer) { EntityDescription.create(serializer) }

    override suspend fun <T> re(function: suspend (DBAccess) -> T): T = tx.re {
        val access = DBAccessImpl(this, it, sql)
        function(access)
    }

    override suspend fun <T> su(function: suspend (DBAccess) -> T): T = tx.su {
        val access = DBAccessImpl(this, it, sql)
        function(access)
    }

    override suspend fun <T> new(function: suspend (DBAccess) -> T): T = tx.new {
        val access = DBAccessImpl(this, it, sql)
        function(access)
    }

    override suspend fun asyncClose() {
        pool.asyncClose()
    }

    override suspend fun createSchema(serializer: KSerializer<out Any>, ifNotExist: Boolean, tableName: String?) {
        re {
            it.update(
                generateSchema(
                    serializer = serializer,
                    ifNotExist = ifNotExist,
                    tableName = tableName,
                    engine = it.dbDatabaseInfo.engine,
                )
            )
        }
    }

    override fun generateSchema(
        engine: DatabaseEngine,
        serializer: KSerializer<out Any>,
        ifNotExist: Boolean,
        tableName: String?
    ): String {
        val sb = StringBuilder()
        sb.append("create table ")
        if (ifNotExist) {
            sb.append("if not exists ")
        }
        sb.append(tableName ?: serializer.tableName).append("(")
        repeat(serializer.descriptor.elementsCount) { index ->
            val annotations = serializer.descriptor.getElementAnnotations(index)
            val useQuotes = annotations.any { it is UseQuotes }
            val isId = annotations.any { it is Id }
            val autoGenerated = annotations.any { it is AutoGenerated }
            val columnType = annotations.find { it is ColumnType }?.let { it as ColumnType }?.type
            val pgColumnType = annotations.find { it is PGColumnType }?.let { it as PGColumnType }?.type
            val sqliteColumnType = annotations.find { it is SqliteColumnType }?.let { it as SqliteColumnType }?.type
            val customType = when (engine) {
                DatabaseEngine.POSTGRESQL -> pgColumnType ?: columnType
                DatabaseEngine.SQLITE -> sqliteColumnType ?: columnType
            }
            val name = serializer.descriptor.getElementName(index)
            val descriptor = serializer.descriptor.getElementDescriptor(index)
            fun notSupportedAutoGenerated(): Nothing =
                throw IllegalArgumentException("Not supported Auto Generated for field ${serializer.descriptor.serialName}.$name")

            val finalColumnType = if (customType == null) {
                when (engine) {
                    DatabaseEngine.POSTGRESQL -> {
                        when (descriptor) {
                            Boolean.serializer().descriptor -> if (autoGenerated) notSupportedAutoGenerated() else "boolean"
                            Byte.serializer().descriptor -> if (autoGenerated) notSupportedAutoGenerated() else "int1"
                            Short.serializer().descriptor -> if (autoGenerated) "smallint" else "int2"
                            Int.serializer().descriptor -> if (autoGenerated) "serial" else "int4"
                            Long.serializer().descriptor -> if (autoGenerated) "bigserial" else "bigint"
                            Char.serializer().descriptor -> if (autoGenerated) notSupportedAutoGenerated() else "character(1)"
                            String.serializer().descriptor -> if (autoGenerated) notSupportedAutoGenerated() else "text"
                            Float.serializer().descriptor -> if (autoGenerated) notSupportedAutoGenerated() else "real"
                            else -> throw IllegalArgumentException("Can't find default type for ${descriptor.serialName}, field: ${serializer.descriptor.serialName}.$name. Use @ColumnType")
                        }
                    }
                    DatabaseEngine.SQLITE -> {
                        when (descriptor) {
                            Boolean.serializer().descriptor -> if (autoGenerated) notSupportedAutoGenerated() else "integer"
                            Byte.serializer().descriptor,
                            Short.serializer().descriptor,
                            Int.serializer().descriptor,
                            Long.serializer().descriptor -> "integer"
                            Char.serializer().descriptor,
                            String.serializer().descriptor -> if (autoGenerated) notSupportedAutoGenerated() else "text"
                            Float.serializer().descriptor,
                            Double.serializer().descriptor -> if (autoGenerated) notSupportedAutoGenerated() else "REAL"
                            else -> throw IllegalArgumentException("Can't find default type for ${descriptor.serialName}, field: ${serializer.descriptor.serialName}.$name. Use @ColumnType")
                        }
                    }
                }
            } else {
                customType
            }

            if (index > 0) {
                sb.append(",")
            }
            if (useQuotes) {
                sb.append("\"")
            }
            sb.append(name)
            if (useQuotes) {
                sb.append("\"")
            }

            sb.append(" ").append(finalColumnType)
            if (isId) {
                sb.append(" PRIMARY KEY")
            }
            if (descriptor.isNullable) {
                sb.append(" null")
            } else {
                sb.append(" not null")
            }
        }
        sb.append(")")
        return sb.toString()
    }
}
