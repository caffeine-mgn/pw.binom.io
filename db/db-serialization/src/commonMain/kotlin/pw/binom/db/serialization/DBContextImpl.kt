package pw.binom.db.serialization

import kotlinx.serialization.KSerializer
import kotlinx.serialization.builtins.ByteArraySerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.descriptors.nullable
import kotlinx.serialization.encoding.CompositeDecoder
import pw.binom.collections.defaultMutableMap
import pw.binom.db.DatabaseEngine
import pw.binom.db.async.AsyncResultSet
import pw.binom.db.async.pool.AsyncConnectionPool

internal class DBContextImpl(val pool: AsyncConnectionPool, val sql: SQLSerialization) : DBContext {
    private val tx = TransactionManagerImpl(pool)
    val statements = defaultMutableMap<String, SQLQueryNamedArguments>()
    val mappers = defaultMutableMap<KSerializer<out Any>, suspend (AsyncResultSet) -> Any>()

  private val entityDescriptions2 = HashMap<KSerializer<*>, EntityDescription2>()

  internal fun getDescription2(k: KSerializer<*>) = entityDescriptions2.getOrPut(k) { EntityDescription2(k) }


    private val entityDescriptions = defaultMutableMap<SerialDescriptor, EntityDescription>()
    override fun getDescription(serialDescriptor: SerialDescriptor): EntityDescription =
        entityDescriptions.getOrPut(serialDescriptor) { EntityDescription.create(serialDescriptor, this) }

    override suspend fun <T> re(function: suspend (DBAccess) -> T): T = tx.re {
        val access = DBAccessImpl(this, it, sql)
        function(access)
    }

    override suspend fun <T> re2(function: suspend (DBAccess2) -> T): T = tx.re {
      val access = DBAccess2Impl(con = it, serializersModule = sql.serializersModule, ctx = this)
        function(access)
    }

    override suspend fun <T> su(function: suspend (DBAccess) -> T): T = tx.su {
        val access = DBAccessImpl(this, it, sql)
        function(access)
    }

    override suspend fun <T> su2(function: suspend (DBAccess2) -> T): T = tx.su {
      val access = DBAccess2Impl(con = it, serializersModule = sql.serializersModule, ctx = this)
        function(access)
    }

    override suspend fun <T> new(function: suspend (DBAccess) -> T): T = tx.new {
        val access = DBAccessImpl(this, it, sql)
        function(access)
    }

    override suspend fun <T> new2(function: suspend (DBAccess2) -> T) = tx.new {
      val access = DBAccess2Impl(con = it, serializersModule = sql.serializersModule, ctx = this)
        function(access)
    }

    override suspend fun <T> no(function: suspend (DBAccess2) -> T) = tx.no {
      val access = DBAccess2Impl(con = it, serializersModule = sql.serializersModule, ctx = this)
        function(access)
    }

    override suspend fun asyncClose() {
        pool.asyncClose()
    }

    override suspend fun createSchema(serializer: KSerializer<out Any>, ifNotExist: Boolean, tableName: String?) {
        re {
          generateSchema(
            serializer = serializer,
            ifNotExist = ifNotExist,
            tableName = tableName,
            engine = it.dbDatabaseInfo.engine,
          ).forEach { sql ->
            it.update(sql)
          }
        }
    }

    override fun generateSchema(
      engine: DatabaseEngine,
      serializer: KSerializer<out Any>,
      ifNotExist: Boolean,
      tableName: String?,
    ): List<String> {
        val sb = StringBuilder()
        sb.append("create table ")
        if (ifNotExist) {
            sb.append("if not exists ")
        }
        sb.append(tableName ?: serializer.tableName).append("(")
        repeat(serializer.descriptor.elementsCount) { index ->
            val annotations = serializer.descriptor.getElementAnnotations(index)
            val useQuotes = annotations.any { it is UseQuotes }
            val isId = annotations.any { it is Id }
            val autoGenerated = annotations.any { it is AutoGenerated }
            val columnType = annotations.find { it is ColumnType }?.let { it as ColumnType }?.type
            val pgColumnType = annotations.find { it is PGColumnType }?.let { it as PGColumnType }?.type
            val sqliteColumnType = annotations.find { it is SqliteColumnType }?.let { it as SqliteColumnType }?.type
            val customType = when (engine) {
                DatabaseEngine.POSTGRESQL -> pgColumnType ?: columnType
                DatabaseEngine.SQLITE -> sqliteColumnType ?: columnType
            }
            val name = serializer.descriptor.getElementName(index)
            val descriptor = serializer.descriptor.getElementDescriptor(index)
            fun notSupportedAutoGenerated(): Nothing =
                throw IllegalArgumentException("Not supported Auto Generated for field ${serializer.descriptor.serialName}.$name")

            val finalColumnType = if (customType == null) {
                when (engine) {
                    DatabaseEngine.POSTGRESQL -> {
                      when (descriptor.nullable) {
                        Boolean.serializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "boolean"
                        Byte.serializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "int1"
                        Short.serializer().descriptor.nullable -> if (autoGenerated) "smallint" else "int2"
                        Int.serializer().descriptor.nullable -> if (autoGenerated) "serial" else "int4"
                        Long.serializer().descriptor.nullable -> if (autoGenerated) "bigserial" else "bigint"
                        Char.serializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "character(1)"
                        String.serializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "text"
                        Float.serializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "real"
                        UUIDSerializer.descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "uuid"
                        ByteArraySerializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "blob"
                            else -> throw IllegalArgumentException("Can't find default type for ${descriptor.serialName}, field: ${serializer.descriptor.serialName}.$name. Use @ColumnType")
                        }
                    }

                    DatabaseEngine.SQLITE -> {
                      when (descriptor.nullable) {
                        Boolean.serializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "integer"
                        Byte.serializer().descriptor.nullable,
                        Short.serializer().descriptor.nullable,
                        Int.serializer().descriptor.nullable,
                        Long.serializer().descriptor.nullable,
                        -> "integer"

                        Char.serializer().descriptor.nullable,
                        String.serializer().descriptor.nullable,
                        -> if (autoGenerated) notSupportedAutoGenerated() else "text"

                        Float.serializer().descriptor.nullable,
                        Double.serializer().descriptor.nullable,
                        -> if (autoGenerated) notSupportedAutoGenerated() else "REAL"

                        UUIDSerializer.descriptor.nullable,
                        ByteArraySerializer().descriptor.nullable,
                        -> if (autoGenerated) notSupportedAutoGenerated() else "blob"
                            else -> throw IllegalArgumentException("Can't find default type for ${descriptor.serialName}, field: ${serializer.descriptor.serialName}.$name. Use @ColumnType")
                        }
                    }
                }
            } else {
                customType
            }

            if (index > 0) {
                sb.append(",")
            }
            if (useQuotes) {
                sb.append("\"")
            }
            sb.append(name)
            if (useQuotes) {
                sb.append("\"")
            }

            sb.append(" ").append(finalColumnType)
            if (isId) {
                sb.append(" PRIMARY KEY")
            }
            if (descriptor.isNullable) {
                sb.append(" null")
            } else {
                sb.append(" not null")
            }
        }
        sb.append(")")
      val result = ArrayList<String>(1)
      result += sb.toString()

      fun generateIndex(index: Index): String? {
        val s = StringBuilder()
        val columns =
          index.columns//.splitToSequence(',', '|', ';').map { it.trim() }.filter { it.isNotEmpty()}.toList()
        if (columns.isEmpty()) {
          return null
        }
        s.append("create ")
        if (index.unique) {
          s.append("unique ")
        }
        s.append("index ")
        if (ifNotExist) {
          s.append("if not exists ")
        }
        val indexName =
          index.name.takeIf { it.isNotEmpty() } ?: "${tableName ?: serializer.tableName}_${columns.joinToString("_")}"
        s.append(indexName).append(" on ").append(tableName ?: serializer.tableName).append(" (")
        var first = true
        columns.forEach { columnName ->
          if (!first) {
            s.append(",")
          }
          first = false
          val i = serializer.descriptor.getElementIndex(columnName)
          if (i == CompositeDecoder.UNKNOWN_NAME) {
            throw IllegalArgumentException("Unknown column $columnName")
          }
          val isUseQuotes = serializer.descriptor.isUseQuotes(i)
          if (isUseQuotes) {
            s.append("\"")
          }
          s.append(columnName)
          if (isUseQuotes) {
            s.append("\"")
          }
        }
        s.append(")")
        return s.toString()
      }

      serializer.descriptor.annotations.forEach {
        when (it) {
          is Index -> result += generateIndex(it) ?: return@forEach
          is Indexes -> it.indexes.forEach {
            result += generateIndex(it) ?: return@forEach
          }
        }
      }
      return result
    }
}
