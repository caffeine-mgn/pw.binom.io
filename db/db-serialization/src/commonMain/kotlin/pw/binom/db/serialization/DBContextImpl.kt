@file:OptIn(ExperimentalSerializationApi::class)

package pw.binom.db.serialization

import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.KSerializer
import kotlinx.serialization.builtins.ByteArraySerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.descriptors.nullable
import kotlinx.serialization.encoding.CompositeDecoder
import pw.binom.collections.defaultMutableMap
import pw.binom.db.DatabaseEngine
import pw.binom.db.async.AsyncResultSet
import pw.binom.db.async.pool.AsyncConnectionPool

internal class DBContextImpl(val pool: AsyncConnectionPool, val sql: SQLSerialization) : DBContext {
  private val tx = TransactionManagerImpl(pool)
  val statements = defaultMutableMap<String, SQLQueryNamedArguments>()
  val mappers = defaultMutableMap<KSerializer<out Any>, suspend (AsyncResultSet) -> Any>()

  private val entityDescriptions2 = HashMap<KSerializer<*>, EntityDescription2Impl>()

  override fun getDescription2(serializer: KSerializer<*>) =
    entityDescriptions2.getOrPut(serializer) { EntityDescription2Impl(serializer) }

  private val entityDescriptions = defaultMutableMap<SerialDescriptor, EntityDescription>()
  override fun getDescription(serialDescriptor: SerialDescriptor): EntityDescription =
    entityDescriptions.getOrPut(serialDescriptor) { EntityDescription.create(serialDescriptor, this) }

  override suspend fun <T> re(function: suspend (DBAccess) -> T): T = tx.re {
    val access = DBAccessImpl(this, it, sql)
    function(access)
  }

  override suspend fun <T> re2(function: suspend (DBAccess2) -> T): T = tx.re {
    val access = DBAccess2Impl(con = it, serializersModule = sql.serializersModule, ctxImpl = this)
    function(access)
  }

  override suspend fun <T> su(function: suspend (DBAccess) -> T): T = tx.su {
    val access = DBAccessImpl(this, it, sql)
    function(access)
  }

  override suspend fun <T> su2(function: suspend (DBAccess2) -> T): T = tx.su {
    val access = DBAccess2Impl(con = it, serializersModule = sql.serializersModule, ctxImpl = this)
    function(access)
  }

  override suspend fun <T> new(function: suspend (DBAccess) -> T): T = tx.new {
    val access = DBAccessImpl(this, it, sql)
    function(access)
  }

  override suspend fun <T> new2(function: suspend (DBAccess2) -> T) = tx.new {
    val access = DBAccess2Impl(con = it, serializersModule = sql.serializersModule, ctxImpl = this)
    function(access)
  }

  override suspend fun <T> no(function: suspend (DBAccess2) -> T) = tx.no {
    val access = DBAccess2Impl(con = it, serializersModule = sql.serializersModule, ctxImpl = this)
    function(access)
  }

  override suspend fun asyncClose() {
    pool.asyncClose()
  }

  override suspend fun createSchema(serializer: KSerializer<out Any>, ifNotExist: Boolean, tableName: String?) {
    re {
      generateSchema(
        serializer = serializer,
        ifNotExist = ifNotExist,
        tableName = tableName,
        engine = it.dbDatabaseInfo.engine,
      ).forEach { sql ->
        it.update(sql)
      }
    }
  }

  override fun generateSchema(
    engine: DatabaseEngine,
    serializer: KSerializer<out Any>,
    ifNotExist: Boolean,
    tableName: String?,
  ): List<String> {
    val sb = StringBuilder()
    sb.append("create table ")
    if (ifNotExist) {
      sb.append("if not exists ")
    }
    sb.append(tableName ?: serializer.tableName).append("(")
    repeat(serializer.descriptor.elementsCount) { index ->
      val annotations = serializer.descriptor.getElementAnnotations(index)
      val useQuotes = annotations.any { it is UseQuotes }
      val isId = annotations.any { it is Id }
      val autoGenerated = annotations.any { it is AutoGenerated }
      val columnType = annotations.find { it is ColumnType }?.let { it as ColumnType }?.type
      val pgColumnType = annotations.find { it is PGColumnType }?.let { it as PGColumnType }?.type
      val sqliteColumnType = annotations.find { it is SqliteColumnType }?.let { it as SqliteColumnType }?.type
      val customType = when (engine) {
        DatabaseEngine.POSTGRESQL -> pgColumnType ?: columnType
        DatabaseEngine.SQLITE -> sqliteColumnType ?: columnType
      }
      val name = serializer.descriptor.getElementName(index)
      val descriptor = serializer.descriptor.getElementDescriptor(index)
      fun notSupportedAutoGenerated(): Nothing =
        throw IllegalArgumentException("Not supported Auto Generated for field ${serializer.descriptor.serialName}.$name")

      val finalColumnType = if (customType == null) {
        when (engine) {
          DatabaseEngine.POSTGRESQL -> {
            when (descriptor.nullable) {
              Boolean.serializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "boolean"
              Byte.serializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "int1"
              Short.serializer().descriptor.nullable -> if (autoGenerated) "smallint" else "int2"
              Int.serializer().descriptor.nullable -> if (autoGenerated) "serial" else "int4"
              Long.serializer().descriptor.nullable -> if (autoGenerated) "bigserial" else "bigint"
              Char.serializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "character(1)"
              String.serializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "text"
              Float.serializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "real"
              UUIDSerializer.descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "uuid"
              ByteArraySerializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "blob"
              else -> throw IllegalArgumentException("Can't find default type for ${descriptor.serialName}, field: ${serializer.descriptor.serialName}.$name. Use @ColumnType")
            }
          }

          DatabaseEngine.SQLITE -> {
            when (descriptor.nullable) {
              Boolean.serializer().descriptor.nullable -> if (autoGenerated) notSupportedAutoGenerated() else "integer"
              Byte.serializer().descriptor.nullable,
              Short.serializer().descriptor.nullable,
              Int.serializer().descriptor.nullable,
              Long.serializer().descriptor.nullable,
              -> "integer"

              Char.serializer().descriptor.nullable,
              String.serializer().descriptor.nullable,
              -> if (autoGenerated) notSupportedAutoGenerated() else "text"

              Float.serializer().descriptor.nullable,
              Double.serializer().descriptor.nullable,
              -> if (autoGenerated) notSupportedAutoGenerated() else "REAL"

              UUIDSerializer.descriptor.nullable,
              ByteArraySerializer().descriptor.nullable,
              -> if (autoGenerated) notSupportedAutoGenerated() else "blob"

              else -> throw IllegalArgumentException("Can't find default type for ${descriptor.serialName}, field: ${serializer.descriptor.serialName}.$name. Use @ColumnType")
            }
          }
        }
      } else {
        customType
      }

      if (index > 0) {
        sb.append(",")
      }
      if (useQuotes) {
        sb.append("\"")
      }
      sb.append(name)
      if (useQuotes) {
        sb.append("\"")
      }

      sb.append(" ").append(finalColumnType)
      if (isId) {
        sb.append(" PRIMARY KEY")
      }
      if (descriptor.isNullable) {
        sb.append(" null")
      } else {
        sb.append(" not null")
      }
    }
    sb.append(")")
    val result = ArrayList<String>(1)
    result += sb.toString()

    fun generateIndex(index: Index): String? {
      val s = StringBuilder()
      val columns =
        index.columns // .splitToSequence(',', '|', ';').map { it.trim() }.filter { it.isNotEmpty()}.toList()
      if (columns.isEmpty()) {
        return null
      }
      s.append("create ")
      if (index.unique) {
        s.append("unique ")
      }
      s.append("index ")
      if (ifNotExist) {
        s.append("if not exists ")
      }
      val indexName =
        index.name.takeIf { it.isNotEmpty() } ?: "${tableName ?: serializer.tableName}_${columns.joinToString("_")}"
      s.append(indexName).append(" on ").append(tableName ?: serializer.tableName).append(" (")
      var first = true
      columns.forEach { columnName ->
        if (!first) {
          s.append(",")
        }
        first = false
        val i = serializer.descriptor.getElementIndex(columnName)
        if (i == CompositeDecoder.UNKNOWN_NAME) {
          throw IllegalArgumentException("Unknown column $columnName")
        }
        val isUseQuotes = serializer.descriptor.isUseQuotes(i)
        if (isUseQuotes) {
          s.append("\"")
        }
        s.append(columnName)
        if (isUseQuotes) {
          s.append("\"")
        }
      }
      s.append(")")
      return s.toString()
    }

    serializer.descriptor.annotations.forEach {
      when (it) {
        is Index -> result += generateIndex(it) ?: return@forEach
        is Indexes -> it.indexes.forEach {
          result += generateIndex(it) ?: return@forEach
        }
      }
    }
    return result
  }
}
