@file:OptIn(ExperimentalSerializationApi::class)

package pw.binom.db.serialization

// import com.ionspin.kotlin.bignum.decimal.BigDecimal
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.InternalSerializationApi
import kotlinx.serialization.KSerializer
import kotlinx.serialization.modules.SerializersModule
import kotlinx.serialization.serializer
import pw.binom.collections.defaultMutableMap
import pw.binom.collections.defaultMutableSet
import pw.binom.date.Calendar
import pw.binom.date.Date
import pw.binom.date.DateTime
import pw.binom.db.ResultSet
import pw.binom.uuid.UUID

val SqlSerializersModule =
  SerializersModule {
    this.contextual(UUID::class, UUIDSerializer)
//    this.contextual(BigDecimal::class, BigDecimalSerializer)
    this.contextual(DateTime::class, DateTimeSerializer)
    this.contextual(Date::class, DateSerializer)
    this.contextual(Calendar::class, CalendarSerializer)
  }

// fun <T : Any> KSerializer<T>.selectQuery(queryPart: String? = null): SelectQueryWithMapper<T> = run {
//    val q = SQLSerialization.selectQuery(this)
//    val txt = if (queryPart == null) {
//        q
//    } else {
//        "$q $queryPart"
//    }
//    SelectQuery(
//        txt
//    ).mapper(SQLSerialization.DEFAULT.mapper(this))
// }

/**
 * Calls [func] for each column. [func] will called with final column name.
 * [mapper] can be use for filter columns or change column name.
 */
fun <T : Any> KSerializer<T>.eachColumn(
  mapper: (String) -> String? = { it },
  func: (String) -> Unit,
) {
  val descriptor = descriptor
  repeat(descriptor.elementsCount) {
    val columnName = mapper(descriptor.getElementName(it)) ?: return@repeat
    val useQuotes = descriptor.getElementAnnotations(it).any { it is UseQuotes }
    if (useQuotes) {
      func("\"$columnName\"")
    } else {
      func(columnName)
    }
  }
}

class SQLSerialization(val serializersModule: SerializersModule = SqlSerializersModule) {
  companion object {
    fun <T : Any> toMap(
      serializer: KSerializer<T>,
      value: T,
      map: MutableMap<String, Any?>,
      columnPrefix: String?,
      serializersModule: SerializersModule,
    ) {
      val encoder =
        SQLEncoderImpl(
          columnPrefix = columnPrefix,
          map = map,
          serializersModule = serializersModule,
        )
      serializer.serialize(encoder, value)
    }

    val DEFAULT = SQLSerialization()

    private fun <T : Any> getTableName(
      serializer: KSerializer<T>,
      tableName: String?,
    ): String = tableName ?: serializer.tableName

    /**
     * Returns auto-generated value columns names ready for database
     */
    internal fun <T : Any> getAutogeneratedColumns(serializer: KSerializer<T>): Set<String> {
      val descriptor = serializer.descriptor
      val out = defaultMutableSet<String>()
      repeat(descriptor.elementsCount) {
        val autoGenerated = descriptor.getElementAnnotations(it).any { it is AutoGenerated }
        val useQuotes = descriptor.getElementAnnotations(it).any { it is UseQuotes }
        if (autoGenerated) {
          out += if (useQuotes) "\"${descriptor.getElementName(it)}\"" else descriptor.getElementName(it)
        }
      }
      return out
    }

    @OptIn(InternalSerializationApi::class)
    private inline fun <reified T : Any> getTableName(tableName: String? = null) =
      getTableName(serializer = T::class.serializer(), tableName = tableName)

    fun <T : Any> selectQuery(
      serializer: KSerializer<T>,
      tableName: String? = null,
    ): String {
      val sb = StringBuilder()
      sb.append("SELECT ")
      val table = getTableName(serializer, tableName)
      val descriptor = serializer.descriptor
      repeat(descriptor.elementsCount) {
        if (it > 0) {
          sb.append(", ")
        }
        val useQuotes = descriptor.getElementAnnotations(it).any { it is UseQuotes }
        if (useQuotes) {
          sb.append("\"")
        }
        sb.append(descriptor.getElementName(it))
        if (useQuotes) {
          sb.append("\"")
        }
      }
      sb.append(" FROM ").append(table)
      return sb.toString()
    }

    fun updateQuery(
      serializer: KSerializer<out Any>,
      tableName: String? = null,
      excludes: Set<String> = emptySet(),
      includes: Set<String> = emptySet(),
    ): String {
      val sb = StringBuilder()
      val descriptor = serializer.descriptor
      val table = getTableName(serializer, tableName = tableName)
      sb.append("UPDATE ").append(table).append(" SET ")
      var first = true
      repeat(descriptor.elementsCount) {
        val el = descriptor.getElementName(it)
        if ((includes.isNotEmpty() && el !in includes) || (el in excludes)) {
          return@repeat
        }
        if (!first) {
          sb.append(", ")
        }
        val useQuotes = descriptor.getElementAnnotations(it).any { it is UseQuotes }
        if (useQuotes) {
          sb.append("\"")
        }
        sb.append(el)
        if (useQuotes) {
          sb.append("\"")
        }
        sb.append("=").append(":").append(el)
        first = false
      }
      if (first) {
        throw IllegalArgumentException("Can't generate update query. All field of ${serializer.descriptor.serialName} are excluded")
      }
      return sb.toString()
    }

    fun <T : Any> insertQuery(
      serializer: KSerializer<T>,
      tableName: String? = null,
    ): String {
      val sb = StringBuilder()
      val table = getTableName(serializer, tableName)
      val descriptor = serializer.descriptor
      sb.append("INSERT INTO ").append(table).append(" (")
      var first = true
      repeat(descriptor.elementsCount) {
        val autoGenerated = descriptor.getElementAnnotations(it).any { it is AutoGenerated }
        if (autoGenerated) {
          return@repeat
        }
        if (!first) {
          sb.append(", ")
        }
        val useQuotes = descriptor.getElementAnnotations(it).any { it is UseQuotes }
        if (useQuotes) {
          sb.append("\"")
        }
        sb.append(descriptor.getElementName(it))
        if (useQuotes) {
          sb.append("\"")
        }
        first = false
      }
      sb.append(") VALUES (")
      first = true
      repeat(descriptor.elementsCount) {
        val autoGenerated = descriptor.getElementAnnotations(it).any { it is AutoGenerated }
        if (autoGenerated) {
          return@repeat
        }
        if (!first) {
          sb.append(", ")
        }
        sb.append(":").append(descriptor.getElementName(it))
        first = false
      }
      sb.append(")")
      return sb.toString()
    }
  }

  fun <T : Any> decode(
    serializer: KSerializer<T>,
    resultSet: ResultSet,
    columnPrefix: String? = null,
  ): T {
    val decoder =
      SQLDecoderImpl(
        columnPrefix = columnPrefix,
        resultSet = resultSet,
        serializersModule = serializersModule,
      )
    return serializer.deserialize(decoder)
  }

  @OptIn(InternalSerializationApi::class)
  inline fun <reified T : Any> writer(
    columnPrefix: String? = null,
    vararg overrideFields: Pair<String, Any?>,
  ) = writer(serializer = T::class.serializer(), columnPrefix = columnPrefix, overrideFields = overrideFields)

  fun <T : Any> writer(
    serializer: KSerializer<T>,
    columnPrefix: String? = null,
    vararg overrideFields: Pair<String, Any?>,
  ): suspend (T) -> Array<Pair<String, Any?>> =
    {
      nameParams(
        serializer = serializer,
        value = it,
        columnPrefix = columnPrefix,
        overrideFields = overrideFields,
      )
    }

  @OptIn(InternalSerializationApi::class)
  inline fun <reified T : Any> mapper(columnPrefix: String? = null) =
    mapper(
      serializer = T::class.serializer(),
      columnPrefix = columnPrefix,
    )

  fun <T : Any> mapper(
    serializer: KSerializer<T>,
    columnPrefix: String? = null,
  ): suspend (pw.binom.db.async.AsyncResultSet) -> T =
    {
      decode(serializer = serializer, resultSet = it, columnPrefix = columnPrefix)
    }

  @OptIn(InternalSerializationApi::class)
  inline fun <reified T : Any> decode(
    resultSet: ResultSet,
    columnPrefix: String? = null,
  ): T =
    decode(
      serializer = T::class.serializer(),
      resultSet = resultSet,
      columnPrefix = columnPrefix,
    )

  fun <T : Any> buildSqlNamedParams(
    serializer: KSerializer<T>,
    value: T,
    columnPrefix: String? = null,
  ): MutableMap<String, Any?> {
    val map = defaultMutableMap<String, Any?>()
    buildSqlNamedParamsTo(
      serializer = serializer,
      value = value,
      map = map,
      columnPrefix = columnPrefix,
    )
    return map
  }

  fun <T : Any> nameParams(
    serializer: KSerializer<T>,
    value: T,
    vararg overrideFields: Pair<String, Any?>,
    columnPrefix: String? = null,
  ): Array<Pair<String, Any?>> {
    val result = buildSqlNamedParams(serializer = serializer, value = value, columnPrefix = columnPrefix)
    val it = result.iterator()
    overrideFields.forEach {
      result[it.first] = it.second
    }
    return Array(result.size) { _ ->
      val e = it.next()
      e.key to e.value
    }
  }

  fun <T : Any> buildSqlNamedParamsTo(
    serializer: KSerializer<T>,
    value: T,
    map: MutableMap<String, Any?>,
    columnPrefix: String? = null,
  ) {
    val encoder =
      SQLEncoderImpl(
        columnPrefix = columnPrefix,
        map = map,
        serializersModule = serializersModule,
      )
    serializer.serialize(encoder, value)
  }
}
