package pw.binom.db.serialization

import kotlinx.serialization.KSerializer
import pw.binom.collections.defaultMutableList

internal class EntityDescription2(val k: KSerializer<*>) {

  private var onConflictTHROWNotReturning: String? = null

  private var params: MutableMap<String, Pair<Boolean, Any?>>? = null

  private class Field(
    val name: String,
    val useQuotes: Boolean,
    val autoGenerated: Boolean,
    val index: Boolean,
    val id: Boolean,
  )

  private val fields = HashMap<String, Field>()

  init {
    ColumnNamesVisitor.forEachFields(k.descriptor) {
        name: String,
        useQuotes: Boolean,
        id: Boolean,
        index: Boolean,
        autoGenerated: Boolean,
      ->
      fields[name] = Field(id = id, index = index, name = name, useQuotes = useQuotes, autoGenerated = autoGenerated)
    }
  }

  private val binder = object : DataBinder {
    override fun get(key: String): Any? = params!![key]
    override fun contains(key: String): Boolean = params!!.containsKey(key)
    override fun set(key: String, value: Any?, useQuotes: Boolean) {
      params!![key] = useQuotes to value
    }
  }

  fun getBinder(params: MutableMap<String, Pair<Boolean, Any?>>): DataBinder {
    this.params = params
    return binder
  }

  @Suppress("DEPRECATION_ERROR")
  fun getInsertStatement(
    params: Map<String, Pair<Boolean, Any?>>,
    onConflict: DBAccess2.ActionOnConflict,
    returning: Boolean,
  ): String {
    if (onConflict == DBAccess2.ActionOnConflict.DoThrow) {
      if (!returning) {
        if (onConflictTHROWNotReturning != null) {
          return onConflictTHROWNotReturning!!
        }
      }
    }
    val sb = StringBuilder()
    sb.append("insert into ").append(getTableName(k.descriptor)).append("(")

    params.entries.forEachIndexed { index, param ->
      if (index > 0) {
        sb.append(",")
      }
      val useQuotes = param.value.first
      if (useQuotes) {
        sb.append("\"")
      }
      sb.append(param.key)
      if (useQuotes) {
        sb.append("\"")
      }
    }
    sb.append(") values(")
    val args = defaultMutableList<Any?>(params.size)
    params.entries.forEachIndexed { index, param ->
      if (index > 0) {
        sb.append(",")
      }
      sb.append("?")
      args += param.value.second
    }
    sb.append(")")

    if (onConflict != DBAccess2.ActionOnConflict.DoThrow) {
      sb.append(" ON CONFLICT (")
      if (onConflict is DBAccess2.ActionOnConflict.OnColumns) {
        var first = true
        onConflict.columns.forEach {
          val column = fields[it]?:throw IllegalArgumentException("Column \"$it\" not found in ${k.descriptor.serialName}")
          if (!first) {
            sb.append(",")
          }
          first = false
          if (column.useQuotes) {
            sb.append("\"")
          }
          sb.append(column.name)
          if (column.useQuotes) {
            sb.append("\"")
          }
        }
      } else {
        var first = true
        fields.values.forEach {
          val id=it.id
          val index=it.index

          if (!index && !id) {
            return@forEach
          }
          if (!first) {
            sb.append(",")
          }
          first = false
          if (it.useQuotes) {
            sb.append("\"")
          }
          sb.append(it.name)
          if (it.useQuotes) {
            sb.append("\"")
          }
        }
      }
      sb.append(")")
      if (onConflict == DBAccess2.ActionOnConflict.DoUpdate || onConflict is DBAccess2.ActionOnConflict.DoUpdateOnColumns) {
        sb.append(" DO UPDATE SET")
        params.entries.forEachIndexed { index, param ->
          if (index > 0) {
            sb.append(",")
          }
          sb.append("?")
          args += param.value.second
        }
      }
      if (onConflict == DBAccess2.ActionOnConflict.DoNothing || onConflict is DBAccess2.ActionOnConflict.DoNothingOnColumns) {
        sb.append(" DO NOTHING")
      }
    }

    if (returning) {
      sb.append(" returning ")
      params.entries.forEachIndexed { index, param ->
        if (index > 0) {
          sb.append(",")
        }
        val useQuotes = param.value.first
        if (useQuotes) {
          sb.append("\"")
        }
        sb.append(param.key)
        if (useQuotes) {
          sb.append("\"")
        }
      }
    }
    val str = sb.toString()
    if (onConflict == DBAccess2.ActionOnConflict.DoThrow) {
      if (!returning) {
        onConflictTHROWNotReturning = str
      }
    }
    return str
  }
}
