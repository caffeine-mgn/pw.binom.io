package pw.binom.db.serialization

import kotlinx.serialization.InternalSerializationApi
import kotlinx.serialization.KSerializer
import kotlinx.serialization.serializer
import pw.binom.db.async.DatabaseInfo

interface DBAccess {
    suspend fun <T : Any> select(query: String, vararg args: Pair<String, Any?>, result: KSerializer<T>): List<T>

    suspend fun update(query: String, vararg args: Pair<String, Any?>): Long

    val dbDatabaseInfo: DatabaseInfo

    /**
     * Replace [value] or insert if [value] already exist
     * Make sure you defined annotation [IndexColumn] for index columns
     */
    suspend fun <T : Any> upsertEntity(
        serializer: KSerializer<T>,
        value: T,
        excludeUpdate: Set<String> = emptySet(),
        updateOnly: Set<String> = emptySet()
    )

    suspend fun deleteEntityFrom(
        from: KSerializer<out Any>,
        queryCondition: String? = null,
        args: Array<out Pair<String, Any?>> = emptyArray(),
        tableName: String? = null,
    ): Long

    suspend fun <T : Any> selectEntityFrom(
        fromSerializer: KSerializer<T>,
        queryCondition: String? = null,
        args: Array<out Pair<String, Any?>> = emptyArray(),
        tableName: String? = null,
    ): List<T>

    suspend fun <T : Any> find(
        serializer: KSerializer<T>,
        key: Any,
        tableName: String? = null,
    ): T?

    suspend fun deleteEntityFrom(
        serializer: KSerializer<out Any>,
        id: Any,
        tableName: String? = null,
    ): Boolean

    /**
     * @param byColumns columns for select conditions. By default (when no define any columns) use field with `@Id`
     */
    suspend fun <T : Any> updateEntity(
        serializer: KSerializer<T>,
        value: T,
        tableName: String? = null,
        includeColumns: Array<String> = emptyArray(),
        excludeColumns: Array<String> = emptyArray(),
        byColumns: Array<String> = emptyArray()
    ): Boolean

    /**
     * Insert [value] into [tableName]. If [tableName] is null will use value from class's [TableName] annotation
     * @param tableName overriding table name for insert [value]
     * @param serializer [value]'s [KSerializer]
     * @param value value for insert into data base
     * @param autoGeneratedResult if not null will call with returning auto generated values
     * @return returns true if inserted success, in other case returns false
     */
    suspend fun <T : Any> insertEntity(
        tableName: String? = null,
        serializer: KSerializer<T>,
        value: T,
        autoGeneratedResult: (suspend (Map<String, String?>) -> Unit)? = null
    ): Boolean

    fun tableName(serializer: KSerializer<out Any>): String
    fun columnName(serializer: KSerializer<out Any>, fieldName: String): String
}

@OptIn(InternalSerializationApi::class)
inline fun <reified T : Any> DBAccess.tableName() =
    tableName(serializer = T::class.serializer())

@OptIn(InternalSerializationApi::class)
inline fun <reified T : Any> DBAccess.columnName(fieldName: String) =
    columnName(serializer = T::class.serializer(), fieldName = fieldName)

@OptIn(InternalSerializationApi::class)
suspend inline fun <reified T : Any> DBAccess.updateEntity(
    value: T,
    tableName: String? = null,
    byColumns: Array<String> = emptyArray(),
    excludeColumns: Array<String> = emptyArray(),
    includeColumns: Array<String> = emptyArray(),
) =
    updateEntity(
        serializer = T::class.serializer(),
        value = value,
        tableName = tableName,
        excludeColumns = excludeColumns,
        includeColumns = includeColumns,
        byColumns = byColumns
    )

/**
 * Insert [value] into [tableName]. If [tableName] is null will use value from class's [TableName] annotation
 *
 * @param tableName overriding table name for insert [value]
 * @param value value for insert into data base
 * @param autoGeneratedResult if not null will call with returning auto generated values
 * @return returns true if inserted success, in other case returns false
 */
@OptIn(InternalSerializationApi::class)
suspend inline fun <reified T : Any> DBAccess.insertEntity(
    value: T,
    tableName: String? = null,
    noinline autoGeneratedResult: (suspend (Map<String, String?>) -> Unit)? = null
) =
    insertEntity(
        serializer = T::class.serializer(),
        value = value,
        tableName = tableName,
        autoGeneratedResult = autoGeneratedResult
    )

@OptIn(InternalSerializationApi::class)
suspend inline fun <reified T : Any> DBAccess.deleteEntityFrom(
    queryCondition: String? = null,
    tableName: String? = null,
    args: Array<out Pair<String, Any?>> = emptyArray(),
) =
    deleteEntityFrom(from = T::class.serializer(), queryCondition = queryCondition, args = args, tableName = tableName)

@OptIn(InternalSerializationApi::class)
suspend inline fun <reified T : Any> DBAccess.upsertEntity(
    value: T,
    excludeUpdate: Set<String> = emptySet(),
    updateOnly: Set<String> = emptySet()
) =
    upsertEntity(
        serializer = T::class.serializer(),
        value = value,
        excludeUpdate = excludeUpdate,
        updateOnly = updateOnly
    )

@OptIn(InternalSerializationApi::class)
suspend inline fun <reified T : Any> DBAccess.selectEntityFrom(
    queryCondition: String? = null,
    args: Array<Pair<String, Any?>> = emptyArray(),
    tableName: String? = null,
) =
    selectEntityFrom(
        fromSerializer = T::class.serializer(),
        queryCondition = queryCondition,
        args = args,
        tableName = tableName
    )