@file:OptIn(ExperimentalSerializationApi::class)

package pw.binom.db.serialization

import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.KSerializer
import pw.binom.collections.defaultMutableList

internal class EntityDescription2Impl(val serializer: KSerializer<*>) : EntityDescription2 {
  private var onConflictTHROWNotReturning: String? = null

  private var params: MutableMap<String, Pair<Boolean, Any?>>? = null

  private class FieldImpl(
    override val name: String,
    override val useQuotes: Boolean,
    override val autoGenerated: Boolean,
    override val index: Boolean,
    override val id: Boolean,
  ) : EntityDescription2.Field

  private val internalFields = HashMap<String, FieldImpl>()
  override val fields: Map<String, EntityDescription2.Field>
    get() = internalFields

  init {
    ColumnNamesVisitor.forEachFields(serializer.descriptor) {
        name: String,
        useQuotes: Boolean,
        id: Boolean,
        index: Boolean,
        autoGenerated: Boolean,
      ->
      internalFields[name] =
        FieldImpl(
          id = id,
          index = index,
          name = name,
          useQuotes = useQuotes,
          autoGenerated = autoGenerated,
        )
    }
  }

  override val idFields: List<EntityDescription2.Field> = fields.values.filter { it.id }
  private val binder =
    object : DataBinder {
      override fun get(key: String): Any? = params!![key]

      override fun contains(key: String): Boolean = params!!.containsKey(key)

      override fun set(
        key: String,
        value: Any?,
        useQuotes: Boolean,
      ) {
        params!![key] = useQuotes to value
      }
    }

  fun getBinder(params: MutableMap<String, Pair<Boolean, Any?>>): DataBinder {
    this.params = params
    return binder
  }

  @Suppress("DEPRECATION_ERROR")
  fun getInsertStatement(
    params: Map<String, Pair<Boolean, Any?>>,
    onConflict: DBAccess2.ActionOnConflict,
    returning: Boolean,
  ): String {
    if (onConflict == DBAccess2.ActionOnConflict.DoThrow) {
      if (!returning) {
        if (onConflictTHROWNotReturning != null) {
          return onConflictTHROWNotReturning!!
        }
      }
    }
    val sb = StringBuilder()
    sb.append("insert into ").append(getTableName(serializer.descriptor)).append("(")

    params.entries.forEachIndexed { index, param ->
      if (index > 0) {
        sb.append(",")
      }
      val useQuotes = param.value.first
      if (useQuotes) {
        sb.append("\"")
      }
      sb.append(param.key)
      if (useQuotes) {
        sb.append("\"")
      }
    }
    sb.append(") values(")
    val args = defaultMutableList<Any?>(params.size)
    params.entries.forEachIndexed { index, param ->
      if (index > 0) {
        sb.append(",")
      }
      sb.append("?")
      args += param.value.second
    }
    sb.append(")")

    if (onConflict != DBAccess2.ActionOnConflict.DoThrow) {
      sb.append(" ON CONFLICT (")
      if (onConflict is DBAccess2.ActionOnConflict.OnColumns) {
        var first = true
        onConflict.columns.forEach {
          val column =
            internalFields[it]
              ?: throw IllegalArgumentException("Column \"$it\" not found in ${serializer.descriptor.serialName}")
          if (!first) {
            sb.append(",")
          }
          first = false
          if (column.useQuotes) {
            sb.append("\"")
          }
          sb.append(column.name)
          if (column.useQuotes) {
            sb.append("\"")
          }
        }
      } else {
        var first = true
        internalFields.values.forEach {
          val id = it.id
          val index = it.index

          if (!index && !id) {
            return@forEach
          }
          if (!first) {
            sb.append(",")
          }
          first = false
          if (it.useQuotes) {
            sb.append("\"")
          }
          sb.append(it.name)
          if (it.useQuotes) {
            sb.append("\"")
          }
        }
      }
      sb.append(")")
      if (onConflict == DBAccess2.ActionOnConflict.DoUpdate || onConflict is DBAccess2.ActionOnConflict.DoUpdateOnColumns) {
        sb.append(" DO UPDATE SET ")
//        println("Update SET:")
//        params.entries.forEachIndexed { index, param ->
//          println("$index -> ${param.key}=${param.value.second ?: "---null---"}")
//        }
        params.entries.forEachIndexed { index, param ->
          if (index > 0) {
            sb.append(",")
          }
          val useQuotes = param.value.first
          if (useQuotes) {
            sb.append("\"")
          }
          sb.append(param.key)
          if (useQuotes) {
            sb.append("\"")
          }
          sb.append("=")
          sb.append("?")
          args += param.value.second
        }
      }
      if (onConflict == DBAccess2.ActionOnConflict.DoNothing || onConflict is DBAccess2.ActionOnConflict.DoNothingOnColumns) {
        sb.append(" DO NOTHING")
      }
    }

    if (returning) {
      sb.append(" returning ")
      internalFields.values.forEachIndexed { index, param ->
        if (index > 0) {
          sb.append(",")
        }
        val useQuotes = param.useQuotes
        if (useQuotes) {
          sb.append("\"")
        }
        sb.append(param.name)
        if (useQuotes) {
          sb.append("\"")
        }
      }
    }
    val str = sb.toString()
    if (onConflict == DBAccess2.ActionOnConflict.DoThrow) {
      if (!returning) {
        onConflictTHROWNotReturning = str
      }
    }
    return str
  }
}
