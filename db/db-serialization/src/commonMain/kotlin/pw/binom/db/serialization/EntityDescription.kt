package pw.binom.db.serialization

import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.KSerializer
import kotlinx.serialization.descriptors.SerialDescriptor
import pw.binom.db.serialization.Index as AIndex

class EntityDescription private constructor(
    val columns: Map<String, Column>,
    val indexes: List<Index>,
    val id: Column?,
    val tableName: String,
    val schemaName: String?,
    val databaseName: String?,
    val useQuotes: Boolean,
) {
    val fullTableName = fullTableName()

    class Index(
        val name: String,
        val list: List<Column>,
        val unique: Boolean,
    )

    class Column(
        val index: Int,
        val id: Boolean,
        val name: String,
        val columnName: String,
        val useQuotes: Boolean,
        val autoGenerated: Boolean,
        val columnPrefix: String?,
    ) {
        val fullColumnName = run {
            val sb = StringBuilder()
            if (useQuotes) {
                sb.append("\"")
            }
            sb.append(columnName)
            if (useQuotes) {
                sb.append("\"")
            }
            sb.toString()
        }
    }

    companion object {
        fun create(serializer: KSerializer<out Any>): EntityDescription =
            create(serializer.descriptor)

        fun create(descriptor: SerialDescriptor): EntityDescription {
            val useQuotes = descriptor.annotations.any { it is UseQuotes }
            val fullTableName = descriptor.annotations
                .find { it is TableName }
                ?.let { it as TableName }
                ?.tableName
                ?: descriptor.serialName
            val columns = HashMap<String, Column>()
            var idColumn: Column? = null
            repeat(descriptor.elementsCount) {
                val fieldDescription = descriptor.getElementDescriptor(it)
                val id = descriptor.getElementAnnotations(it).any { it is Id }
                if (id && idColumn != null) {
                    throw IllegalArgumentException("${descriptor.serialName} has several @Id fields")
                }
                val autoGenerated = descriptor.getElementAnnotations(it).any { it is AutoGenerated }
                val columnPrefix =
                    descriptor.getElementAnnotations(it).find { it is Embedded }?.let { it as Embedded }?.prefix
                val useQuotes = descriptor.getElementAnnotations(it).any { it is UseQuotes }
                val name = descriptor.getElementName(it)
                val columnName = descriptor.annotations
                    .find { it is ColumnName }
                    ?.let { it as ColumnName }
                    ?.columnName
                    ?: name
                val column = Column(
                    id = id,
                    name = name,
                    index = it,
                    columnName = columnName,
                    useQuotes = useQuotes,
                    autoGenerated = autoGenerated,
                    columnPrefix = columnPrefix,
                )

                columns[name] = column
                if (id) {
                    idColumn = column
                }
            }

            val indexes = descriptor.annotations
                .mapNotNull { it as? AIndex }
                .map { index ->
                    val indexColumns = index.columns
                        .split(',', ':')
                        .map { it.trim() }
                    val columns = indexColumns.map { indexName ->
                        columns[indexName]
                            ?: throw IllegalArgumentException("Can't create index ${index.name}: column \"$indexName\" not found")
                    }
                    Index(
                        name = index.name,
                        list = columns,
                        unique = index.unique
                    )
                }

            val tableNameItems = fullTableName.split('.', limit = 3).asReversed()
            return EntityDescription(
                columns = columns,
                id = idColumn,
                tableName = tableNameItems[0],
                schemaName = tableNameItems.getOrNull(1),
                databaseName = tableNameItems.getOrNull(2),
                useQuotes = useQuotes,
                indexes = indexes,
            )
        }
    }

    private fun fullTableName(): String {
        val sb = StringBuilder()
        fun addWithQ(name: String) {
            if (useQuotes) {
                sb.append("\"")
            }
            sb.append(name)
            if (useQuotes) {
                sb.append("\"")
            }
        }
        if (databaseName != null) {
            addWithQ(databaseName)
        }
        if (schemaName != null) {
            if (databaseName != null) {
                sb.append(".")
            }
            addWithQ(schemaName)
        }
        if (databaseName != null || schemaName != null) {
            sb.append(".")
        }
        addWithQ(tableName)
        return sb.toString()
    }
}

@OptIn(ExperimentalSerializationApi::class)
val <T : Any> KSerializer<T>.tableName: String
    get() {
        val descriptor = descriptor
        val useQuotes = descriptor.annotations.any { it is UseQuotes }
        descriptor.annotations.forEach {
            if (it is TableName) {
                return if (useQuotes) {
                    "\"${it.tableName}\""
                } else {
                    it.tableName
                }
            }
        }
        return if (useQuotes) {
            "\"${descriptor.serialName}\""
        } else {
            descriptor.serialName
        }
    }
