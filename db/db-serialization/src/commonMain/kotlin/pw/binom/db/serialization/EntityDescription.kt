package pw.binom.db.serialization

import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.KSerializer
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.SerialDescriptor
import pw.binom.db.serialization.Index as AIndex

class EntityDescription private constructor(
    val columns: Map<String, Column>,
    val indexes: List<Index>,
    val id: Column?,
    val tableName: String,
    val schemaName: String?,
    val databaseName: String?,
    val useQuotes: Boolean,
    val serialDescriptor: SerialDescriptor,
    val descriptorContext: DescriptorContext,
) {
    val fullTableName = fullTableName()

    class Index(
        val name: String,
        val list: List<Column>,
        val unique: Boolean,
    )

    private fun internalGetAllColumns(
        prefix: String,
        forceUseQuotes: Boolean,
        list: MutableList<String>,
        filter: (Column) -> Boolean
    ) {
        columns.forEach { (name, column) ->
            if (!filter(column)) {
                return@forEach
            }
//            if (column.serialDescriptor.kind is PrimitiveKind) {
//            }
            val embedded = serialDescriptor.getElementAnnotation<Embedded>(column.index) != null
            if (embedded) {
                val splitter = serialDescriptor.getElementAnnotation<EmbeddedSplitter>(column.index)?.splitter ?: "_"
                descriptorContext.getDescription(column.serialDescriptor).internalGetAllColumns(
                    prefix = name + splitter,
                    forceUseQuotes = column.useQuotes || forceUseQuotes,
                    list = list,
                    filter = filter,
                )
            } else {
                list += if (column.useQuotes || forceUseQuotes) {
                    "\"$prefix$name\""
                } else {
                    "$prefix$name"
                }
            }
        }
    }

    val flatColumnsWithoutAutogenerated: List<String> by lazy {
        val out = ArrayList<String>()
        internalGetAllColumns(
            prefix = "",
            forceUseQuotes = false,
            list = out,
            filter = { !it.autoGenerated }
        )
        out
    }

    val flatColumns: List<String> by lazy {
        val out = ArrayList<String>()
        internalGetAllColumns(
            prefix = "",
            forceUseQuotes = false,
            list = out,
            filter = { true }
        )
        out
    }

    class Column(
        val index: Int,
        val id: Boolean,
        val name: String,
        val columnName: String,
        val useQuotes: Boolean,
        val autoGenerated: Boolean,
        val columnPrefix: String?,
        val serialDescriptor: SerialDescriptor,
        val isEmbedded: Boolean,
    ) {
        fun getFullColumnName(out: StringBuilder, forceUseQuotes: Boolean, prefix: String?) {
            if (useQuotes || forceUseQuotes) {
                out.append("\"")
            }
            if (prefix != null) {
                out.append(prefix)
            }
            out.append(columnName)
            if (useQuotes || forceUseQuotes) {
                out.append("\"")
            }
            out.toString()
        }

        val fullColumnName = run {
            val sb = StringBuilder()
            if (useQuotes) {
                sb.append("\"")
            }
            sb.append(columnName)
            if (useQuotes) {
                sb.append("\"")
            }
            sb.toString()
        }
    }

    companion object {
        fun create(serializer: KSerializer<out Any>, descriptorContext: DescriptorContext,): EntityDescription =
            create(serializer.descriptor, descriptorContext)

        fun create(descriptor: SerialDescriptor, descriptorContext: DescriptorContext,): EntityDescription {
            val useQuotes = descriptor.annotations.any { it is UseQuotes }
            val fullTableName = descriptor.annotations
                .find { it is TableName }
                ?.let { it as TableName }
                ?.tableName
                ?: descriptor.serialName
            val columns = HashMap<String, Column>()
            var idColumn: Column? = null
            repeat(descriptor.elementsCount) {
                val fieldDescription = descriptor.getElementDescriptor(it)
                val id = descriptor.getElementAnnotations(it).any { it is Id }
                if (id && idColumn != null) {
                    throw IllegalArgumentException("${descriptor.serialName} has several @Id fields")
                }
                val autoGenerated = descriptor.getElementAnnotations(it).any { it is AutoGenerated }
                val isEmbedded = descriptor.getElementAnnotation<Embedded>(it) != null
                if (fieldDescription.kind is PrimitiveKind && isEmbedded) {
                    throw IllegalArgumentException("Primitive ${descriptor.getElementName(it)} can't be embedded")
                }
//                val columnPrefix =
//                    descriptor.getElementAnnotations(it).find { it is Embedded }?.let { it as Embedded }?.prefix
                val useQuotes = descriptor.getElementAnnotations(it).any { it is UseQuotes }
                val name = descriptor.getElementName(it)
                val columnName = descriptor.annotations
                    .find { it is ColumnName }
                    ?.let { it as ColumnName }
                    ?.columnName
                    ?: name
                val column = Column(
                    id = id,
                    name = name,
                    index = it,
                    columnName = columnName,
                    useQuotes = useQuotes,
                    autoGenerated = autoGenerated,
                    columnPrefix = null,
                    serialDescriptor = fieldDescription,
                    isEmbedded = isEmbedded,
                )

                columns[name] = column
                if (id) {
                    idColumn = column
                }
            }

            val indexes = descriptor.annotations
                .mapNotNull { it as? AIndex }
                .map { index ->
                    val indexColumns = index.columns
                        .split(',', ':')
                        .map { it.trim() }
                    val columns = indexColumns.map { indexName ->
                        columns[indexName]
                            ?: throw IllegalArgumentException("Can't create index ${index.name}: column \"$indexName\" not found")
                    }
                    Index(
                        name = index.name,
                        list = columns,
                        unique = index.unique
                    )
                }

            val tableNameItems = fullTableName.split('.', limit = 3).asReversed()
            return EntityDescription(
                columns = columns,
                id = idColumn,
                tableName = tableNameItems[0],
                schemaName = tableNameItems.getOrNull(1),
                databaseName = tableNameItems.getOrNull(2),
                useQuotes = useQuotes,
                indexes = indexes,
                serialDescriptor = descriptor,
                descriptorContext = descriptorContext,
            )
        }
    }

    private fun fullTableName(): String {
        val sb = StringBuilder()
        fun addWithQ(name: String) {
            if (useQuotes) {
                sb.append("\"")
            }
            sb.append(name)
            if (useQuotes) {
                sb.append("\"")
            }
        }
        if (databaseName != null) {
            addWithQ(databaseName)
        }
        if (schemaName != null) {
            if (databaseName != null) {
                sb.append(".")
            }
            addWithQ(schemaName)
        }
        if (databaseName != null || schemaName != null) {
            sb.append(".")
        }
        addWithQ(tableName)
        return sb.toString()
    }
}

@OptIn(ExperimentalSerializationApi::class)
val <T : Any> KSerializer<T>.tableName: String
    get() {
        val descriptor = descriptor
        val useQuotes = descriptor.annotations.any { it is UseQuotes }
        descriptor.annotations.forEach {
            if (it is TableName) {
                return if (useQuotes) {
                    "\"${it.tableName}\""
                } else {
                    it.tableName
                }
            }
        }
        return if (useQuotes) {
            "\"${descriptor.serialName}\""
        } else {
            descriptor.serialName
        }
    }
