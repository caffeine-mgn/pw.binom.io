package pw.binom.db.serialization

import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.KSerializer
import pw.binom.doFreeze
import pw.binom.db.serialization.Index as AIndex

class EntityDescription private constructor(
    val serializer: KSerializer<out Any>,
    val columns: Map<String, Column>,
    val indexes: List<Index>,
    val id: Column?,
    val tableName: String,
    val schemaName: String?,
    val databaseName: String?,
    val useQuotes: Boolean,
) {
    val fullTableName = fullTableName()
    init {
        doFreeze()
    }

    class Index(
        val name: String,
        val list: List<Column>,
        val unique: Boolean,
    ) {
        init {
            doFreeze()
        }
    }

    class Column(
        val index: Int,
        val id: Boolean,
        val name: String,
        val columnName: String,
        val useQuotes: Boolean,
        val autoGenerated: Boolean
    ) {
        val fullColumnName = run {
            val sb = StringBuilder()
            if (useQuotes) {
                sb.append("\"")
            }
            sb.append(columnName)
            if (useQuotes) {
                sb.append("\"")
            }
            sb.toString()
        }

        init {
            doFreeze()
        }
    }

    companion object {
        fun create(serializer: KSerializer<out Any>): EntityDescription {
            val descriptor = serializer.descriptor
            val useQuotes = descriptor.annotations.any { it is UseQuotes }
            val fullTableName = descriptor.annotations.find { it is TableName }
                ?.let { it as TableName }
                ?.tableName
                ?: descriptor.serialName
            val columns = HashMap<String, Column>()
            var idColumn: Column? = null
            repeat(descriptor.elementsCount) {
                val id = descriptor.getElementAnnotations(it).any { it is Id }
                if (id && idColumn != null) {
                    throw IllegalArgumentException("${serializer.descriptor.serialName} has several @Id fields")
                }
                val autoGenerated = descriptor.getElementAnnotations(it).any { it is AutoGenerated }
                val useQuotes = descriptor.getElementAnnotations(it).any { it is UseQuotes }
                val name = descriptor.getElementName(it)
                val columnName = descriptor.annotations.find { it is ColumnName }
                    ?.let { it as TableName }
                    ?.tableName
                    ?: name
                val column = Column(
                    id = id,
                    name = name,
                    index = it,
                    columnName = columnName,
                    useQuotes = useQuotes,
                    autoGenerated = autoGenerated,
                )
                columns[name] = column
                if (id) {
                    idColumn = column
                }
            }

            val indexes = descriptor.annotations.mapNotNull { it as? AIndex }.map { index ->
                val indexColumns = index.columns.split(',', ':').map { it.trim() }
                val columns = indexColumns.map { indexName ->
                    columns[indexName]
                        ?: throw IllegalArgumentException("Can't create index ${index.name}: column \"$indexName\" not found")
                }
                Index(
                    name = index.name,
                    list = columns,
                    unique = index.unique
                )
            }

            val tableNameItems = fullTableName.split('.', limit = 3).asReversed()

            return EntityDescription(
                serializer = serializer,
                columns = columns,
                id = idColumn,
                tableName = tableNameItems[0],
                schemaName = tableNameItems.getOrNull(1),
                databaseName = tableNameItems.getOrNull(2),
                useQuotes = useQuotes,
                indexes = indexes,
            )
        }
    }

    private fun fullTableName(): String {
        val sb = StringBuilder()
        fun addWithQ(name: String) {
            if (useQuotes) {
                sb.append("\"")
            }
            sb.append(name)
            if (useQuotes) {
                sb.append("\"")
            }
        }
        if (databaseName != null) {
            addWithQ(databaseName)
        }
        if (schemaName != null) {
            if (databaseName != null) {
                sb.append(".")
            }
            addWithQ(schemaName)
        }
        if (databaseName != null || schemaName != null) {
            sb.append(".")
        }
        addWithQ(tableName)
        return sb.toString()
    }
}

@OptIn(ExperimentalSerializationApi::class)
val <T : Any> KSerializer<T>.tableName: String
    get() {
        val descriptor = descriptor
        val useQuotes = descriptor.annotations.any { it is UseQuotes }
        descriptor.annotations.forEach {
            if (it is TableName) {
                return if (useQuotes) {
                    "\"${it.tableName}\""
                } else {
                    it.tableName
                }

            }
        }
        return if (useQuotes) {
            "\"${descriptor.serialName}\""
        } else {
            descriptor.serialName
        }
    }