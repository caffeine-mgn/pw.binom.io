package pw.binom.db.serialization

import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.KSerializer
import pw.binom.doFreeze
import pw.binom.db.serialization.Index as AIndex

class EntityDescription private constructor(
    val serializer: KSerializer<out Any>,
    val columns: Map<String, Column>,
    val indexes: List<Index>,
    val id: Column?,
    val tableName: String,
    val useQuotes: Boolean,
) {
    init {
        doFreeze()
    }

    class Index(
        val name: String,
        val list: List<Column>,
        val unique: Boolean,
    )

    class Column(
        val index: Int,
        val id: Boolean,
        val name: String,
        val columnName: String,
        val useQuotes: Boolean,
        val autoGenerated: Boolean
    ) {
        init {
            doFreeze()
        }
    }

    companion object {
        fun create(serializer: KSerializer<out Any>): EntityDescription {
            val descriptor = serializer.descriptor
            val useQuotes = descriptor.annotations.any { it is UseQuotes }
            val tableName = descriptor.annotations.find { it is TableName }
                ?.let { it as TableName }
                ?.tableName
                ?: descriptor.serialName
            val columns = HashMap<String, Column>()
            var idColumn: Column? = null
            repeat(descriptor.elementsCount) {
                val id = descriptor.getElementAnnotations(it).any { it is Id }
                if (id && idColumn != null) {
                    throw IllegalArgumentException("${serializer.descriptor.serialName} has several @Id fields")
                }
                val autoGenerated = descriptor.getElementAnnotations(it).any { it is AutoGenerated }
                val useQuotes = descriptor.getElementAnnotations(it).any { it is UseQuotes }
                val name = descriptor.getElementName(it)
                val columnName = descriptor.annotations.find { it is ColumnName }
                    ?.let { it as TableName }
                    ?.tableName
                    ?: name
                val column = Column(
                    id = id,
                    name = name,
                    index = it,
                    columnName = columnName,
                    useQuotes = useQuotes,
                    autoGenerated = autoGenerated,
                )
                columns[name] = column
                if (id) {
                    idColumn = column
                }
            }

            val indexes = descriptor.annotations.mapNotNull { it as? AIndex }.map { index ->
                val indexColumns = index.columns.split(',', ':').map { it.trim() }
                val columns = indexColumns.map { indexName ->
                    columns[indexName]
                        ?: throw IllegalArgumentException("Can't create index ${index.name}: column \"$indexName\" not found")
                }
                Index(
                    name = index.name,
                    list = columns,
                    unique = index.unique
                )
            }

            return EntityDescription(
                serializer = serializer,
                columns = columns,
                id = idColumn,
                tableName = tableName,
                useQuotes = useQuotes,
                indexes = indexes,
            )
        }
    }
}

@OptIn(ExperimentalSerializationApi::class)
val <T : Any> KSerializer<T>.tableName: String
    get() {
        val descriptor = descriptor
        val useQuotes = descriptor.annotations.any { it is UseQuotes }
        descriptor.annotations.forEach {
            if (it is TableName) {
                return if (useQuotes) {
                    "\"${it.tableName}\""
                } else {
                    it.tableName
                }

            }
        }
        return if (useQuotes) {
            "\"${descriptor.serialName}\""
        } else {
            descriptor.serialName
        }
    }