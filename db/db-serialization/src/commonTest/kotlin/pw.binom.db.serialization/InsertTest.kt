package pw.binom.db.serialization

import kotlinx.serialization.Serializable
import pw.binom.concurrency.sleep
import pw.binom.db.async.pool.AsyncConnectionPool
import pw.binom.db.postgresql.async.PGConnection
import pw.binom.db.sqlite.AsyncSQLiteConnector
import pw.binom.io.use
import pw.binom.network.NetworkAddress
import pw.binom.network.NetworkDispatcher
import pw.binom.nextUuid
import pw.binom.testContainer.TestContainer
import pw.binom.testContainer.invoke
import kotlin.random.Random
import kotlin.test.Test
import kotlin.test.assertEquals

class InsertTest {

    object PostgresContainer : TestContainer(
        image = "postgres:11",
        environments = mapOf(
            "POSTGRES_USER" to "postgres",
            "POSTGRES_PASSWORD" to "postgres",
            "POSTGRES_DB" to "test"
        ),
        ports = listOf(
            Port(internalPort = 5432)
        ),
        reuse = false,
    ) {
        val externalPort
            get() = ports[0].externalPort
    }

    fun db(sql: SQLSerialization = SQLSerialization.DEFAULT, func: suspend (DBContext) -> Unit) {
        val manager = NetworkDispatcher()
        try {
            PostgresContainer {
                sleep(1000)
                manager.runSingle {
                    AsyncConnectionPool.create(maxConnections = 1) {
                        PGConnection.connect(
                            address = NetworkAddress.Immutable("127.0.0.1", PostgresContainer.externalPort),
                            userName = "postgres",
                            password = "postgres",
                            dataBase = "test",
                            networkDispatcher = manager
                        )
                    }.use { pool ->
                        val context = DBContext.create(pool, sql)
                        func(context)
                    }
                }
            }
        } catch (e: Throwable) {
            throw RuntimeException("Exception on PostgreSQL", e)
        }
        try {
            manager.runSingle {
                AsyncConnectionPool.create(maxConnections = 1) {
                    AsyncSQLiteConnector.memory(Random.nextUuid().toString())
                }.use { pool ->
                    val context = DBContext.create(pool, sql)
                    func(context)
                }
            }
        } catch (e: Throwable) {
            throw RuntimeException("Exception on SQLite", e)
        }
    }

    @TableName("my_table")
    @Serializable
    class Entity(
        @Id
        @AutoGenerated
        val id: Long = 0,

        @ColumnType("varchar(60)")
        val title: String,
    )

    @Test
    fun getInsertedValueTest() {
        db { context ->
            var insertedId = 0L
            context.createSchema<Entity>()
            context.re {
                it.insertEntity(Entity(title = "ololo")) {
                    insertedId = it["id"]!!.toLong()
                }
            }
            assertEquals(1L, insertedId)
        }
    }
}