package pw.binom.db.serialization

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.TimeoutCancellationException
import kotlinx.coroutines.test.runTest
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeout
import kotlinx.serialization.Serializable
import pw.binom.charset.Charsets
import pw.binom.concurrency.sleep
import pw.binom.db.async.pool.AsyncConnectionPool
import pw.binom.db.postgresql.async.PGConnection
import pw.binom.db.sqlite.AsyncSQLiteConnector
import pw.binom.io.socket.NetworkAddress
import pw.binom.io.use
import pw.binom.network.Network
import pw.binom.uuid.nextUuid
import kotlin.random.Random
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.time.Duration.Companion.seconds
import kotlin.time.ExperimentalTime
import kotlin.time.TimeSource

class InsertTest {

    @OptIn(ExperimentalTime::class)
    private suspend fun connectToPostgres(address: NetworkAddress): PGConnection {
        return withContext(Dispatchers.Default) {
            val start = TimeSource.Monotonic.markNow()
            withTimeout(10.seconds) {
                while (true) {
                    try {
                        println("Connection...")
                        val con = PGConnection.connect(
                            address = address,
                            charset = Charsets.UTF8,
                            userName = "postgres",
                            password = "postgres",
                            dataBase = "test"
                        )
                        println("Connected after ${start.elapsedNow()}")
                        return@withTimeout con
                    } catch (e: Throwable) {
                        if (e is TimeoutCancellationException) {
                            throw e
                        }
                        sleep(1000)
                        println("Error on connect: $e")
                        continue
                    }
                }
                TODO()
            }
        }
    }

    fun db(sql: SQLSerialization = SQLSerialization.DEFAULT, func: suspend (DBContext) -> Unit) = runTest {
        withContext(Dispatchers.Network) {
            println("---===Test PostgreSQL===---")
            try {
                val pool = AsyncConnectionPool.create(maxConnections = 1) {
                    connectToPostgres(NetworkAddress.create(host = "127.0.0.1", port = 6102))
                }
                DBContext.create(pool, sql).use { context ->
                    func(context)
                }
            } catch (e: Throwable) {
                throw RuntimeException("Exception on PostgreSQL", e)
            }
            println("---===Test SQLite===---")
            try {
                val pool = AsyncConnectionPool.create(maxConnections = 1) {
                    AsyncSQLiteConnector.memory(Random.nextUuid().toString())
                }
                DBContext.create(pool, sql).use { context ->
                    func(context)
                }
            } catch (e: Throwable) {
                e.printStackTrace()
                throw RuntimeException("Exception on SQLite", e)
            }
        }
    }

    @TableName("my_table")
    @Serializable
    class Entity(
        @Id
        @AutoGenerated
        val id: Long = 0,

        @ColumnType("varchar(60)")
        val title: String,
    )

    @Test
    fun getInsertedValueTest() {
        db { context ->
            var insertedId = 0L
            context.createSchema<Entity>()
            context.re {
                it.insertEntity(Entity(title = "ololo")) {
                    insertedId = it["id"]!!.toLong()
                }
            }
            assertEquals(1L, insertedId)
        }
    }
}
