---#include <stdint.h>#ifdef _WIN32    #include <winsock.h>    #include <ws2tcpip.h>    #include <wspiapi.h>    #include <ws2def.h>    typedef int socklen_t;#else    #include <netinet/tcp.h>    #include <arpa/inet.h>    #include <netdb.h>    #include <fcntl.h>#endif#include <errno.h>#ifndef SOCKET#define SOCKET int#endif/* Detect platform endianness at compile time */// If boost were available on all platforms, could use this instead to detect endianness// #include <boost/predef/endian.h>// When available, these headers can improve platform endianness detection#ifdef __has_include // C++17, supported as extension to C++11 in clang, GCC 5+, vs2015#  if __has_include(<endian.h>)#    include <endian.h> // gnu libc normally provides, linux#  elif __has_include(<machine/endian.h>)#    include <machine/endian.h> //open bsd, macos#  elif __has_include(<sys/param.h>)#    include <sys/param.h> // mingw, some bsd (not open/macos)#  elif __has_include(<sys/isadefs.h>)#    include <sys/isadefs.h> // solaris#  endif#endif#if !defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)#  if (defined(__BYTE_ORDER__)  && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) || \     (defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN) || \	 (defined(_BYTE_ORDER) && _BYTE_ORDER == _BIG_ENDIAN) || \	 (defined(BYTE_ORDER) && BYTE_ORDER == BIG_ENDIAN) || \     (defined(__sun) && defined(__SVR4) && defined(_BIG_ENDIAN)) || \     defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || \     defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__) || \     defined(_M_PPC)#    define __BIG_ENDIAN__#  elif (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || /* gcc */\     (defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN) /* linux header */ || \	 (defined(_BYTE_ORDER) && _BYTE_ORDER == _LITTLE_ENDIAN) || \	 (defined(BYTE_ORDER) && BYTE_ORDER == LITTLE_ENDIAN) /* mingw header */ ||  \     (defined(__sun) && defined(__SVR4) && defined(_LITTLE_ENDIAN)) || /* solaris */ \     defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || \     defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || \     defined(_M_IX86) || defined(_M_X64) || defined(_M_IA64) || /* msvc for intel processors */ \     defined(_M_ARM) /* msvc code on arm executes in little endian mode */#    define __LITTLE_ENDIAN__#  endif#endif#if defined(bswap16) || defined(bswap32) || defined(bswap64)#  error "unexpected define!" // freebsd may define these; probably just need to undefine them#endif/* Define byte-swap functions, using fast processor-native built-ins where possible */#if defined(_MSC_VER) // needs to be first because msvc doesn't short-circuit after failing defined(__has_builtin)#  define bswap16(x)     _byteswap_ushort((x))#  define bswap32(x)     _byteswap_ulong((x))#  define bswap64(x)     _byteswap_uint64((x))#elif (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)#  define bswap16(x)     __builtin_bswap16((x))#  define bswap32(x)     __builtin_bswap32((x))#  define bswap64(x)     __builtin_bswap64((x))#elif defined(__has_builtin) && __has_builtin(__builtin_bswap64)  /* for clang; gcc 5 fails on this and && shortcircuit fails; must be after GCC check */#  define bswap16(x)     __builtin_bswap16((x))#  define bswap32(x)     __builtin_bswap32((x))#  define bswap64(x)     __builtin_bswap64((x))#else    /* even in this case, compilers often optimize by using native instructions */    static inline uint16_t bswap16(uint16_t x) {		return ((( x  >> 8 ) & 0xffu ) | (( x  & 0xffu ) << 8 ));	}    static inline uint32_t bswap32(uint32_t x) {        return ((( x & 0xff000000u ) >> 24 ) |                (( x & 0x00ff0000u ) >> 8  ) |                (( x & 0x0000ff00u ) << 8  ) |                (( x & 0x000000ffu ) << 24 ));    }    static inline uint64_t bswap64(uint64_t x) {        return ((( x & 0xff00000000000000ull ) >> 56 ) |                (( x & 0x00ff000000000000ull ) >> 40 ) |                (( x & 0x0000ff0000000000ull ) >> 24 ) |                (( x & 0x000000ff00000000ull ) >> 8  ) |                (( x & 0x00000000ff000000ull ) << 8  ) |                (( x & 0x0000000000ff0000ull ) << 24 ) |                (( x & 0x000000000000ff00ull ) << 40 ) |                (( x & 0x00000000000000ffull ) << 56 ));    }#endif#if __BIG_ENDIAN__unsigned long internal_htonll(unsigned long value) {    return value;}unsigned long internal_ntohll(unsigned long value) {    return value;}unsigned char internal_isBigEndian(){    return 1;}#elif defined(__LITTLE_ENDIAN__)unsigned long internal_htonll(unsigned long value) {    return (((unsigned long)htonl((value) & 0xFFFFFFFF) << 32) | htonl((value) >> 32));}unsigned long internal_ntohll(unsigned long value) {    return (((unsigned long)ntohl((value) & 0xFFFFFFFF) << 32) | ntohl((value) >> 32));}unsigned char internal_isBigEndian(){    return 0;}#else#error "Unknown Endian"#endifuint16_t internal_htons(uint16_t netshort){    return htons(netshort);}uint16_t internal_ntohs(uint16_t netshort){    return ntohs(netshort);}int internal_htonl(int netshort){    return htonl(netshort);}int internal_ntohl(int netshort){    return ntohl(netshort);}// typedef unsigned int socklen_t;typedef struct addrinfo internal_addrinfo;typedef struct sockaddr_in6 internal_sockaddr_in6;int internal_getSocketPort(SOCKET native){    struct sockaddr_in sin;    socklen_t addrlen = sizeof(sin);    int r = getsockname(native, (struct sockaddr *)&sin, &addrlen);    if (r == -1) {        return -1;    } else {        return ntohs(sin.sin_port);    }}int internal_setsockopt(SOCKET __fd, int __level, int __optname, void* __optval, int __optlen){    return setsockopt(__fd, __level, __optname, (char*)__optval, __optlen);}int internal_addr_get_family(void* ptr){    struct sockaddr_in* addr = (struct sockaddr_in*)ptr;    if (addr->sin_family==AF_INET6){            return 6;        }    if (addr->sin_family == AF_INET){        return 4;    }    #ifndef _WIN32    if (addr->sin_family == AF_UNIX){        return 3;    }    #endif    return -1;}void internal_ipv4_to_ipv6(void* src, void* dest, int multicast){    memcpy(&dest[16-4], src, 4);    memset(dest, 0, 10);    memset(&dest[10], multicast ? 0 : 0xFF, 2);}int internal_addr_ipv4_to_ipv6(void* input_ptr, void* out_ptr){    struct sockaddr_in* addr = (struct sockaddr_in*)input_ptr;    if (addr->sin_family == AF_INET6){        return 0;    }    struct sockaddr_in6* out = (struct sockaddr_in6*)out_ptr;    out->sin6_family = AF_INET6;    out->sin6_port = addr->sin_port;    internal_ipv4_to_ipv6(&addr->sin_addr, &out->sin6_addr, 0);    return 1;}int internal_copy_address(struct sockaddr* sockaddr, void* data, int* size){    if (sockaddr->sa_family == AF_INET){        auto addr = (struct sockaddr_in*)sockaddr;        memcpy(            data,            addr,            sizeof(struct sockaddr_in)        );        *size = sizeof(struct sockaddr_in);        return 1;    }    if (sockaddr->sa_family == AF_INET6){        auto addr = (struct sockaddr_in6*)sockaddr;        memcpy(            data,            addr,            sizeof(struct sockaddr_in6)        );        *size = sizeof(struct sockaddr_in);        return 1;    }    return 0;}void internal_copy_addrinfo(struct addrinfo* result, void*data, int* size){    memcpy(        data,        result->ai_addr,        result->ai_addrlen    );    *size = result->ai_addrlen;}void internal_address_host_to_string(void* address, char* output, int outputSize) {    struct sockaddr_in* addr = (struct sockaddr_in*)address;    auto family = addr->sin_family;    if (family == AF_INET){        inet_ntop(            AF_INET,            &addr->sin_addr,            output,            outputSize        );    } else {        struct sockaddr_in6* addr6 = (struct sockaddr_in6*)address;        inet_ntop(            AF_INET6,            &addr6->sin6_addr,            output,            outputSize        );    }}void* internal_find_network_address(const char* host, const char* port){    struct addrinfo hints;    memset(&hints, 0, sizeof(hints));    hints.ai_flags = AI_CANONNAME;    hints.ai_family = AF_UNSPEC;    hints.ai_socktype = SOCK_STREAM;    hints.ai_protocol = IPPROTO_TCP;    struct addrinfo* result;    while (1) {        auto err = getaddrinfo(host, port, &hints, &result);        if (err == EAI_AGAIN && errno == EAGAIN || err == EAI_NONAME) {            return 0;        }        if (err == 0){            break;        } else {            return 0;        }    }    return result;}void* internal_next_network_address(void* previews_address){    return (void*)(((struct addrinfo*)previews_address)->ai_next);}void internal_free_network_addresses(void* first_address){    freeaddrinfo(first_address);}int internal_set_socket_blocked_mode(SOCKET socket, int value){    #ifdef _WIN32        int nonBlocking = value ? 0 : 1;        if (ioctlsocket(socket, FIONBIO, &nonBlocking) == -1) {//            if (GetLastError() == WSAENOTSOCK) {//                return 0;//            }            return 0;        }        return 1;    #else        auto flags = fcntl(socket, F_GETFL, 0);        auto newFlags = value ? flags ^ O_NONBLOCK : flags | O_NONBLOCK;        if (fcntl(socket, F_SETFL, newFlags) != 0) {            return 0;        }        return 1;    #endif}int internal_unbind(SOCKET socket){    int flag = 1;    return setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(int));}int internal_close_socket(SOCKET socket){    if (internal_unbind(socket)<0){        return 0;    }#ifdef _WIN32    shutdown(socket, SD_BOTH);    closesocket(socket);#else    shutdown(socket, SHUT_RDWR);    close(socket);#endif    return 1;}#ifndef SOCKET_ERROR#define SOCKET_ERROR -1#endifint internal_set_allow_ipv6(SOCKET socket){    int flag = 0;    auto iResult = setsockopt(        socket,        IPPROTO_IPV6,        IPV6_V6ONLY,        &flag,        sizeof(int)    );    if (iResult == SOCKET_ERROR) {        return 0;    }    return 1;}int internal_create_socket(int v1,int v2, int v3){    return socket(v1, v2, v3);}int internal_send_to_socket_udp(SOCKET socket, void* data_ptr, int data_size, int options, internal_sockaddr_in6* addr_ptr){    return sendto(socket, data_ptr, data_size, options, (struct sockaddr*)addr_ptr, sizeof(struct sockaddr_in6));}int internal_tcp_nodelay(SOCKET sock, int value){    int yes = value>0 ? 1 : 0;    return setsockopt(sock,                    IPPROTO_TCP,                    TCP_NODELAY,                    (char *) &yes,                    sizeof(int)         );}