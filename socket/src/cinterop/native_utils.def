
---

#include <stdint.h>
#ifdef _WIN32
    #include <winsock.h>
    #include <ws2tcpip.h>
    #include <wspiapi.h>
    #include <ws2def.h>
    typedef int socklen_t;
#else
    #include <netinet/tcp.h>
    #include <arpa/inet.h>
    #include <netdb.h>
    #include <fcntl.h>
#endif

#include <errno.h>
#include <string.h>

#ifndef SOCKET
#define SOCKET int
#endif
/*
// Detect platform endianness at compile time

// If boost were available on all platforms, could use this instead to detect endianness
// #include <boost/predef/endian.h>

// When available, these headers can improve platform endianness detection
#ifdef __has_include // C++17, supported as extension to C++11 in clang, GCC 5+, vs2015
#  if __has_include(<endian.h>)
#    include <endian.h> // gnu libc normally provides, linux
#  elif __has_include(<machine/endian.h>)
#    include <machine/endian.h> //open bsd, macos
#  elif __has_include(<sys/param.h>)
#    include <sys/param.h> // mingw, some bsd (not open/macos)
#  elif __has_include(<sys/isadefs.h>)
#    include <sys/isadefs.h> // solaris
#  endif
#endif

#if !defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
#  if (defined(__BYTE_ORDER__)  && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) || \
     (defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN) || \
	 (defined(_BYTE_ORDER) && _BYTE_ORDER == _BIG_ENDIAN) || \
	 (defined(BYTE_ORDER) && BYTE_ORDER == BIG_ENDIAN) || \
     (defined(__sun) && defined(__SVR4) && defined(_BIG_ENDIAN)) || \
     defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || \
     defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__) || \
     defined(_M_PPC)
#    define __BIG_ENDIAN__
#  elif (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || \
     (defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN) || \
	 (defined(_BYTE_ORDER) && _BYTE_ORDER == _LITTLE_ENDIAN) || \
	 (defined(BYTE_ORDER) && BYTE_ORDER == LITTLE_ENDIAN)  ||  \
     (defined(__sun) && defined(__SVR4) && defined(_LITTLE_ENDIAN)) || \
     defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || \
     defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || \
     defined(_M_IX86) || defined(_M_X64) || defined(_M_IA64) || \
     defined(_M_ARM)
#    define __LITTLE_ENDIAN__
#  endif
#endif

#if defined(bswap16) || defined(bswap32) || defined(bswap64)
#  error "unexpected define!" // freebsd may define these; probably just need to undefine them
#endif

// Define byte-swap functions, using fast processor-native built-ins where possible
#if defined(_MSC_VER) // needs to be first because msvc doesn't short-circuit after failing defined(__has_builtin)
#  define bswap16(x)     _byteswap_ushort((x))
#  define bswap32(x)     _byteswap_ulong((x))
#  define bswap64(x)     _byteswap_uint64((x))
#elif (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
#  define bswap16(x)     __builtin_bswap16((x))
#  define bswap32(x)     __builtin_bswap32((x))
#  define bswap64(x)     __builtin_bswap64((x))
#elif defined(__has_builtin) && __has_builtin(__builtin_bswap64)  // for clang; gcc 5 fails on this and && shortcircuit fails; must be after GCC check
#  define bswap16(x)     __builtin_bswap16((x))
#  define bswap32(x)     __builtin_bswap32((x))
#  define bswap64(x)     __builtin_bswap64((x))
#else
    // even in this case, compilers often optimize by using native instructions
    static inline uint16_t bswap16(uint16_t x) {
		return ((( x  >> 8 ) & 0xffu ) | (( x  & 0xffu ) << 8 ));
	}
    static inline uint32_t bswap32(uint32_t x) {
        return ((( x & 0xff000000u ) >> 24 ) |
                (( x & 0x00ff0000u ) >> 8  ) |
                (( x & 0x0000ff00u ) << 8  ) |
                (( x & 0x000000ffu ) << 24 ));
    }
    static inline uint64_t bswap64(uint64_t x) {
        return ((( x & 0xff00000000000000ull ) >> 56 ) |
                (( x & 0x00ff000000000000ull ) >> 40 ) |
                (( x & 0x0000ff0000000000ull ) >> 24 ) |
                (( x & 0x000000ff00000000ull ) >> 8  ) |
                (( x & 0x00000000ff000000ull ) << 8  ) |
                (( x & 0x0000000000ff0000ull ) << 24 ) |
                (( x & 0x000000000000ff00ull ) << 40 ) |
                (( x & 0x00000000000000ffull ) << 56 ));
    }
#endif

#if __BIG_ENDIAN__
unsigned long internal_htonll(unsigned long value) {
    return value;
}
unsigned long internal_ntohll(unsigned long value) {
    return value;
}
unsigned char internal_isBigEndian(){
    return 1;
}
#elif defined(__LITTLE_ENDIAN__)

unsigned long internal_htonll(unsigned long value) {
    return (((unsigned long)htonl((value) & 0xFFFFFFFF) << 32) | htonl((value) >> 32));
}

unsigned long internal_ntohll(unsigned long value) {
    return (((unsigned long)ntohl((value) & 0xFFFFFFFF) << 32) | ntohl((value) >> 32));
}

unsigned char internal_isBigEndian(){
    return 0;
}

#else
#error "Unknown Endian"
#endif

uint16_t internal_htons(uint16_t netshort){
    return htons(netshort);
}

uint16_t internal_ntohs(uint16_t netshort){
    return ntohs(netshort);
}


int internal_htonl(int netshort){
    return htonl(netshort);
}

int internal_ntohl(int netshort){
    return ntohl(netshort);
}

// typedef unsigned int socklen_t;
typedef struct addrinfo internal_addrinfo;
typedef struct sockaddr_in6 internal_sockaddr_in6;

int internal_getSocketPort(SOCKET native){
    struct sockaddr_in6 sin;
    int addrlen = sizeof(sin);
    int r = getsockname(native, (struct sockaddr *)&sin, &addrlen);
    if (r == -1) {
        return -1;
    } else {
        return ntohs(sin.sin6_port);
    }
}

int internal_setsockopt(SOCKET __fd, int __level, int __optname, void* __optval, int __optlen){
    return setsockopt(__fd, __level, __optname, (char*)__optval, __optlen);
}

int internal_addr_get_family(void* ptr){
    struct sockaddr_in* addr = (struct sockaddr_in*)ptr;
    if (addr->sin_family==AF_INET6){
            return 6;
        }
    if (addr->sin_family == AF_INET){
        return 4;
    }
    #ifndef _WIN32
    if (addr->sin_family == AF_UNIX){
        return 3;
    }
    #endif
    return -1;
}

void internal_ipv4_to_ipv6(void* src, void* dest, int multicast){
    memcpy(&dest[16-4], src, 4);
    memset(dest, 0, 10);
    memset(&dest[10], multicast ? 0 : 0xFF, 2);
}

int internal_addr_ipv4_to_ipv6(void* input_ptr, void* out_ptr){
    struct sockaddr_in* addr = (struct sockaddr_in*)input_ptr;
    if (addr->sin_family == AF_INET6){
        return 0;
    }

    if (addr->sin_family != AF_INET){
        return -1;
    }

    struct sockaddr_in6* out = (struct sockaddr_in6*)out_ptr;
    internal_ipv4_to_ipv6(&addr->sin_addr, &out->sin6_addr, 0);
    out->sin6_family = AF_INET6;
    out->sin6_port = addr->sin_port;
    return 1;
}

int internal_copy_address(struct sockaddr* sockaddr, void* data, int* size){
    if (sockaddr->sa_family == AF_INET){
        auto addr = (struct sockaddr_in*)sockaddr;
        memcpy(
            data,
            addr,
            sizeof(struct sockaddr_in)
        );
        *size = sizeof(struct sockaddr_in);
        return 1;
    }
    if (sockaddr->sa_family == AF_INET6){
        auto addr = (struct sockaddr_in6*)sockaddr;
        memcpy(
            data,
            addr,
            sizeof(struct sockaddr_in6)
        );
        *size = sizeof(struct sockaddr_in);
        return 1;
    }
    return 0;
}

void internal_copy_addrinfo(struct addrinfo* result, void*data, int* size){
    memcpy(
        data,
        result->ai_addr,
        result->ai_addrlen
    );
    *size = result->ai_addrlen;
}

void internal_address_host_to_string(void* address, char* output, int outputSize) {
    struct sockaddr_in* addr = (struct sockaddr_in*)address;
    auto family = addr->sin_family;
    if (family == AF_INET){
        inet_ntop(
            AF_INET,
            &addr->sin_addr,
            output,
            outputSize
        );
    } else {
        struct sockaddr_in6* addr6 = (struct sockaddr_in6*)address;
        inet_ntop(
            AF_INET6,
            &addr6->sin6_addr,
            output,
            outputSize
        );
    }
}

void* internal_find_network_address(const char* host, const char* port){
    struct addrinfo hints;
    memset(&hints, 0, sizeof(hints));
    hints.ai_flags = AI_CANONNAME;
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    struct addrinfo* result;
    while (1) {
        auto err = getaddrinfo(host, port, &hints, &result);
        if (err == EAI_AGAIN && errno == EAGAIN || err == EAI_NONAME) {
            return 0;
        }
        if (err == 0){
            break;
        } else {
            return 0;
        }
    }
    return result;
}

void* internal_next_network_address(void* previews_address){
    return (void*)(((struct addrinfo*)previews_address)->ai_next);
}

void internal_free_network_addresses(void* first_address){
    freeaddrinfo(first_address);
}

int internal_unbind(SOCKET socket){
    int flag = 1;
    return setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(int));
}

int internal_close_socket(SOCKET socket){
    if (internal_unbind(socket)<0){
        return 0;
    }
#ifdef _WIN32
    shutdown(socket, SD_BOTH);
    closesocket(socket);
#else
    shutdown(socket, SHUT_RDWR);
    close(socket);
#endif
    return 1;
}

#ifndef SOCKET_ERROR
#define SOCKET_ERROR -1
#endif

int internal_set_allow_ipv6(SOCKET socket){
    int flag = 0;
    auto iResult = setsockopt(
        socket,
        IPPROTO_IPV6,
        IPV6_V6ONLY,
        &flag,
        sizeof(int)
    );
    if (iResult == SOCKET_ERROR) {
        return 0;
    }
    return 1;
}

#ifdef _WIN32
static int network_inited = 0;
#endif

int internal_create_socket(int v1, int v2, int v3){
    #ifdef _WIN32
    if (network_inited==0){
        WSADATA wsa_data;
        auto r = WSAStartup(MAKEWORD(2, 2), &wsa_data);
        if (r!=0){
            return 0;
        }
    }
    #endif
    return socket(v1, v2, v3);
}

int internal_send_to_socket_udp(SOCKET socket, void* data_ptr, int data_size, int options, internal_sockaddr_in6* addr_ptr){
    return sendto(socket, data_ptr, data_size, options, (struct sockaddr*)addr_ptr, sizeof(struct sockaddr_in6));
}

int internal_tcp_nodelay(SOCKET sock, int value){
    int yes = value>0 ? 1 : 0;
    return setsockopt(sock,
                    IPPROTO_TCP,
                    TCP_NODELAY,
                    (char *) &yes,
                    sizeof(int)
         );
}

int internal_get_last_error(){
#ifdef _WIN32
    return GetLastError();
#else
    return errno;
#endif
}
#ifdef _WIN32
unsigned long internal_inet_addr(const char *cp){
    return inet_addr(cp);
}
#else
in_addr_t internal_inet_addr(const char *cp){
    return inet_addr(cp);
}
#endif

int internal_get_socket_error(SOCKET sock) {
    int error = -1;
    int len = sizeof(error);
    int result = getsockopt(sock, SOL_SOCKET, SO_ERROR, (char*)&error, &len);
    if (result != 0){
        return -2;
    }
    return error;
}
*/

int internal_set_socket_blocked_mode(SOCKET socket, int value){
    #ifdef _WIN32
        int nonBlocking = value ? 0 : 1;
        if (ioctlsocket(socket, FIONBIO, &nonBlocking) != 0) {
//            if (GetLastError() == WSAENOTSOCK) {
//                return 0;
//            }
            return 0;
        }
        return 1;
    #else
        auto flags = fcntl(socket, F_GETFL, 0);
        auto newFlags = value ? flags ^ O_NONBLOCK : flags | O_NONBLOCK;

        if (fcntl(socket, F_SETFL, newFlags) != 0) {
            return 0;
        }
        return 1;
    #endif
}
